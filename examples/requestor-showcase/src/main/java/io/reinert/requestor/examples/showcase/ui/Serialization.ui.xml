<!DOCTYPE ui:UiBinder SYSTEM "http://dl.google.com/gwt/DTD/xhtml.ent">
<!--
~ Copyright 2015 Danilo Reinert
~
~ Licensed under the Apache License, Version 2.0 (the "License");
~ you may not use this file except in compliance with the License.
~ You may obtain a copy of the License at
~
~     http://www.apache.org/licenses/LICENSE-2.0
~
~ Unless required by applicable law or agreed to in writing, software
~ distributed under the License is distributed on an "AS IS" BASIS,
~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~ See the License for the specific language governing permissions and
~ limitations under the License.
-->
<ui:UiBinder xmlns:ui='urn:ui:com.google.gwt.uibinder'
             xmlns:g='urn:import:com.google.gwt.user.client.ui'>
  <g:HTMLPanel>
    <!-- JSON SECTION -->
    <g:HTMLPanel styleName="requestor-showcase-section">
      <h1 class="page-header" id="json-serialization">JSON Serialization</h1>
      <p class="lead">
        Requestor has built-in serialization for JSON.
      </p>

      <div class="requestor-showcase-innersection">
        <h3>Overlays</h3>
        <p>
          Overlay Types are a great feature from GWT to deal with JSON data efficiently.
          They interoperate with native javascript objects with zero overhead.
        </p>

        <p>
          With one configuration you can enable JSON serialization for Overlay Types:
          in you GWT module descriptor set the <code>RequestorInitializer</code> to be <code>RequestorInitializerForJson</code>.
        </p>

        <div class="highlight">
          <pre ui:field="overlaysSetup" class="xml">
            <code>&lt;replace-with class=&quot;io.reinert.requestor.SessionInitializerForJson&quot;&gt;
              <br/>&#32;&#32;&lt;when-type-is class="io.reinert.requestor.SessionInitializer"/&gt;
              <br/>&lt;/replace-with&gt;
            </code>
          </pre>
        </div>

        <p>
          Now, your <code>Requestor</code> container is initialized with a serializer and deserializer for JSON-Overlays.
          <br/>
          When you send a request with some overlay type in the payload, it will be serialized with the browser's <code>JSON#stringify</code> method.
          <br/>
          When you ask an overlay type in a request, the response payload will be deserialized using <code>JsonUtils#safeEval</code>.
          You can alternatively use <code>JsonUtils#unsafeEval</code> (faster but not secure) by setting the public flag <code>OverlaySerializer#USE_SAFE_EVAL</code> to false.
        </p>
      </div>

      <div class="requestor-showcase-innersection">
        <h3>JavaBean Interfaces</h3>
        <p>
          GWT has a powerful feature to serialize/deserialize JavaBean Interfaces to/from JSON content: the <strong>AutoBean Framework</strong>.
          It can be used both in server and client sides.
        </p>

        <p>
          If you are working with JavaBean interfaces, you can enable AutoBeans auto-serialization for serializing and deserializing your interfaces:
          just import the <code>RequestorWithAutoBean</code> module in your GWT module descriptor.
        </p>

        <div class="highlight">
          <pre ui:field="autobeansSetup" class="xml">
            <code>&lt;inherits name=&quot;io.reinert.requestor.RequestorWithAutoBean&quot;/&gt;
            </code>
          </pre>
        </div>

        <p>
          Now, annotate each JavaBean interface with the <code>@Json</code> annotation (present in <em>requestor-annotations</em> dependency).
          Requestor will handle the serialization of the annotated types using the AutoBean Framework.
          More information can be found at the <a href="https://github.com/reinert/requestor/wiki/JavaBean-Interface-JSON-Serialization" target="_blank">docs</a>.
        </p>

        <div class="requestor-callout requestor-callout-danger">
          <h4>Deserialize arrays only to List or Set</h4>
          <p>
            The AutoBean Framework has a special implementation for deserializing objects efficiently.
            It doesn't deserialize arrays to specific collection types (List or Set implementations like ArrayList or HashSet).
            Thereby, we cannot ask for any concrete collection classes when requesting for collections of objects.
            Use only <code>List.class</code> or <code>Set.class</code> when you intend to retrieve a collection result.
          </p>
        </div>

        <div class="requestor-callout requestor-callout-info">
          <h4>Use Requestor to get instances of the annotated types</h4>
          <p>
            Requestor automatically generates factories for the annotated interfaces.
            So if you need to obtain new instances of these types you can resort to <code>Requestor#getInstance(Class&lt;T&gt;)</code>.
            Alternatively you can get the Provider&lt;T&gt; with <code>Requestor#getProvider(Class&lt;T&gt;)</code> and later get an instance with <code>Provider#getInstance()</code>.
          </p>
        </div>
      </div>

      <div class="requestor-showcase-innersection">
        <h3>POJOs</h3>
        <p>
          It is also possible to enable JSON serialization of Plain Old Java Objects (POJOs).
          Requestor has an extension that integrates the <a href="https://github.com/nmorel/gwt-jackson/" target="_blank">gwt-jackson</a> library to its serialization mechanism: <strong>requestor-gwtjackson</strong>.
          Add this dependency to your project and import the following GWT module:
        </p>

        <div class="highlight">
          <pre ui:field="gwtjacksonSetup" class="xml">
            <code>&lt;inherits name=&quot;io.reinert.requestor.RequestorWithGwtJackson&quot;/&gt;
            </code>
          </pre>
        </div>

        <p>
          Now, annotate each POJO with the <code>@Json</code> annotation (present in <em>requestor-annotations</em> dependency).
          Requestor will handle the serialization of the annotated types using the gwt-jackson library.
          More information can be found at the <a href="https://github.com/reinert/requestor/wiki/POJO-JSON-Serialization" target="_blank">docs</a>.
        </p>

        <div class="requestor-callout requestor-callout-info">
          <h4>Use gwt-jackson's full feature set</h4>
          <p>
            The requestor-gwtjackson extension completely integrates the gwt-jackson library to your project.
            Therefore, you can make full use of all gwt-jackson's features.
          </p>
        </div>
      </div>
    </g:HTMLPanel>

  <!-- CUSTOM SECTION -->
  <g:HTMLPanel styleName="requestor-showcase-section">
    <h1 class="page-header" id="custom-serialization">Custom Serialization</h1>
    <p class="lead">
      Create Serializers and Deserializers for specific classes and media types.
    </p>

    <div class="requestor-showcase-innersection">
      <h3>Deserializers</h3>
      <p>
        Deserializers are responsible for deserializing raw content of some media type to an object.
      </p>

      <p>
        To create a deserializer you must implement the <code>Deserializer</code> interface.
        You must implement deserialization of a single serialized element and of a collection of elements.
      </p>

      <div class="highlight">
        <pre ui:field="myXmlDeserializer" class="java">
          <code>class MyXmlDeserializer implements Deserializer&lt;MyObject&gt; {
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public Class&lt;MyObject&gt; handledType() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return MyObject.class;
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public String[] mediaType() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return new String[]{&quot;*/xml&quot;};
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public MyObject deserialize(String response, DeserializationContext context) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int stringFieldStart = response.indexOf(&quot;&lt;stringField&gt;&quot;) + 13;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int stringFieldEnd = response.indexOf(&quot;&lt;/stringField&gt;&quot;, stringFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;String stringField = response.substring(stringFieldStart, stringFieldEnd);
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intFieldStart = response.indexOf(&quot;&lt;intField&gt;&quot;, stringFieldEnd) + 10;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intFieldEnd = response.indexOf(&quot;&lt;/intField&gt;&quot;, intFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intField = Integer.parseInt(response.substring(intFieldStart, intFieldEnd));
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int dateFieldStart = response.indexOf(&quot;&lt;dateField&gt;&quot;, intFieldEnd) + 11;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int dateFieldEnd = response.indexOf(&quot;&lt;/dateField&gt;&quot;, dateFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;Date dateField = new Date(Long.parseLong(response.substring(dateFieldStart, dateFieldEnd)));
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return new MyObject(stringField, intField, dateField);
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public &lt;C extends Collection&lt;MyObject&gt;&gt; C deserialize(Class&lt;C&gt; collectionType, String response, DeserializationContext ctx) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;C collection = ctx.getInstance(collectionType);
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int nextStart = response.indexOf(&quot;&lt;my&gt;&quot;);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;while (nextStart != -1) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int nextEnd = response.indexOf(&quot;&lt;/my&gt;&quot;, nextStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;collection.add(deserialize(response.substring(nextStart + 4, nextEnd), ctx));
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;nextStart = response.indexOf(&quot;&lt;my&gt;&quot;, nextEnd);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return collection;
            <br/>&#32;&#32;&#32;&#32;}
            <br/>}
          </code>
        </pre>
      </div>

      <p>
        Make your deserializer available to Requestor by registering it.
      </p>

      <div class="highlight">
        <pre ui:field="myXmlDeserializerReg" class="java">
          <code>requestor.addDeserializer(new MyXmlDeserializer());</code>
        </pre>
      </div>

      <p>
        <em>Note: #addDeserializer returns a Registration instance which enables you to later cancel the registration.</em>
      </p>
    </div>

    <div class="requestor-showcase-innersection">
      <h3>Serializers</h3>
      <p>
        Serializers are responsible for both serializing and deserializing objects of some media type.
      </p>

      <p>
        To create a serializer you must implement the <code>Serializer</code> interface.
      </p>

      <div class="highlight">
        <pre ui:field="myXmlSerializer" class="java">
          <code>class MyXmlSerializer implements Serializer&lt;MyObject&gt; {
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public Class&lt;MyObject&gt; handledType() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return MyObject.class;
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public String[] mediaType() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;/* Return an array of media type patterns; wildcards are acceptable */
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return new String[]{"*/xml"};
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public String serialize(MyObject myObject, SerializationContext ctx) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return "&lt;my&gt;&lt;stringField&gt;" + myObject.getStringField() + "&lt;/stringField&gt;"
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+ "&lt;intField&gt;" + myObject.getIntField() + "&lt;/intField&gt;"
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+ "&lt;dateField&gt;" + myObject.getDateField().getTime() + "&lt;/dateField&gt;&lt;/my&gt;";
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public String serialize(Collection&lt;MyObject&gt; myCollection, SerializationContext ctx) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;StringBuilder sb = new StringBuilder("&lt;array&gt;");
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;for (MyObject myObject : myCollection) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sb.append(serialize(myObject, ctx));
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return sb.append("&lt;/array&gt;").toString();
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public MyObject deserialize(String response, DeserializationContext context) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int stringFieldStart = response.indexOf(&quot;&lt;stringField&gt;&quot;) + 13;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int stringFieldEnd = response.indexOf(&quot;&lt;/stringField&gt;&quot;, stringFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;String stringField = response.substring(stringFieldStart, stringFieldEnd);
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intFieldStart = response.indexOf(&quot;&lt;intField&gt;&quot;, stringFieldEnd) + 10;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intFieldEnd = response.indexOf(&quot;&lt;/intField&gt;&quot;, intFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intField = Integer.parseInt(response.substring(intFieldStart, intFieldEnd));
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int dateFieldStart = response.indexOf(&quot;&lt;dateField&gt;&quot;, intFieldEnd) + 11;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int dateFieldEnd = response.indexOf(&quot;&lt;/dateField&gt;&quot;, dateFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;Date dateField = new Date(Long.parseLong(response.substring(dateFieldStart, dateFieldEnd)));
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return new MyObject(stringField, intField, dateField);
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public &lt;C extends Collection&lt;MyObject&gt;&gt; C deserialize(Class&lt;C&gt; collectionType, String response, DeserializationContext ctx) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;C collection = ctx.getInstance(collectionType);
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int nextStart = response.indexOf(&quot;&lt;my&gt;&quot;);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;while (nextStart != -1) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int nextEnd = response.indexOf(&quot;&lt;/my&gt;&quot;, nextStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;collection.add(deserialize(response.substring(nextStart + 4, nextEnd), ctx));
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;nextStart = response.indexOf(&quot;&lt;my&gt;&quot;, nextEnd);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return collection;
            <br/>&#32;&#32;&#32;&#32;}
            <br/>}
          </code>
        </pre>
      </div>

      <p>
        Make your serializer available to Requestor by registering it.
      </p>

      <div class="highlight">
        <pre ui:field="myXmlSerializerReg" class="java">
          <code>requestor.addSerializer(new MyXmlSerializer());</code>
        </pre>
      </div>

      <p>
        <em>Note: #addSerializer returns a Registration instance which enables you to later cancel the registration.</em>
      </p>
    </div>

    <div class="requestor-showcase-innersection">
      <h3>JSON Serializer</h3>
      <p>
        If you find yourself needing to implement custom serialization/deserialization to/from JSON, you may find useful to extend the JsonObjectSerializer abstract class.
        It requires the implementation of only two methods for reading and writing a single JSON record.
      </p>

      <div class="highlight">
        <pre ui:field="myJsonSerializer" class="java">
          <code>class MyJsonSerializer extends JsonObjectSerializer&lt;MyObject&gt; {
            <br/>
            <br/>&#32;&#32;&#32;&#32;public MyJsonSerializer() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;super(MyObject.class);
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public MyObject readJson(JsonRecordReader reader, DeserializationContext context) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return new MyObject(reader.readString(&quot;stringField&quot;), reader.readIntPrimitive(&quot;intField&quot;),
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;new Date(reader.readLong(&quot;dateField&quot;)));
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public void writeJson(MyObject myObject, JsonRecordWriter writer, SerializationContext context) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;writer.writeString(&quot;stringField&quot;, myObject.getStringField());
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;writer.writeInt(&quot;intField&quot;, myObject.getIntField());
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;writer.writeDouble(&quot;dateField&quot;, myObject.getDateField().getTime());
            <br/>&#32;&#32;&#32;&#32;}
            <br/>}
          </code>
        </pre>
      </div>
    </div>
  </g:HTMLPanel>

  <!-- CUSTOM SECTION -->
  <g:HTMLPanel styleName="requestor-showcase-section">
    <h1 class="page-header" id="multiple-serialization">Multiple Serialization</h1>
    <p class="lead">
      Requestor is prepared to handle serialization of several media types for the same java type.
    </p>

    <p>
      Suppose you need to exchange the same object in different formats, XML and JSON.
      Requestor selects the right serializer by matching both the class and the media type (extracted from Content-Type header).
      So you can have multiple serializers registered for the same class, as long as they handle different media type patterns.
    </p>

    <p>
      Let's test the examples described above.
      Having the class MyObject with the fields stringField, intField and dateField, we then register the serializers.
    </p>

    <div class="highlight">
      <pre ui:field="testReg" class="java">
        <code>requestor.addSerializer(new MyXmlSerializer()); /* XML serializer for MyObject */
          <br/>requestor.addSerializer(new MyJsonSerializer()); /* JSON serializer for MyObject */
        </code>
      </pre>
    </div>

    <p>
      Now let's make some requests and check if the data are correctly serialized and deserialized.
    </p>

    <!-- XML -->
    <p>
      Get a single xml element. The mocked url <em>http://www.mocky.io/v2/54aa8cf807b5f2bc0f21ba08</em> returns a single MyObject xml element.
      Also, note that the request has a Content-Type header with the value "application/xml". It enables Requestor to match the correct serializer.
    </p>
    <div class="highlight">
      <pre ui:field="singleXmlGet" class="java">
        <code>requestor.req("http://www.mocky.io/v2/54aa8cf807b5f2bc0f21ba08").get(MyObject.class)...</code>
      </pre>
    </div>
    <g:HTMLPanel styleName="action-panel">
      <g:HTMLPanel styleName="action">
        <g:Button ui:field="singleXmlGetButton" styleName="btn">GET</g:Button>
      </g:HTMLPanel>
      <textarea ui:field="singleXmlGetTextArea" class="form-control result" rows="3" readonly="readonly"/>
    </g:HTMLPanel>

    <p>
      Get a collection xml element. The mocked url <em>http://www.mocky.io/v2/54aa8e1407b5f2d20f21ba09</em> returns a xml array of MyObject.
      Also, note that the request has a Content-Type header with the value "application/xml". It enables Requestor to match the correct serializer.
    </p>
    <div class="highlight">
      <pre ui:field="collectionXmlGet" class="java">
        <code>requestor.req("http://www.mocky.io/v2/54aa8e1407b5f2d20f21ba09").get(MyObject.class, List.class)...</code>
      </pre>
    </div>
    <g:HTMLPanel styleName="action-panel">
      <g:HTMLPanel styleName="action">
        <g:Button ui:field="collectionXmlGetButton" styleName="btn">GET</g:Button>
      </g:HTMLPanel>
      <textarea ui:field="collectionXmlGetTextArea" class="form-control result" rows="3" readonly="readonly"/>
    </g:HTMLPanel>

    <p>
      Post a single xml element.
    </p>
    <div class="highlight">
      <pre ui:field="singleXmlPost" class="java">
        <code>requestor.req("http://httpbin.org/post")
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.contentType("application/xml") /* It must match the serializer mediaType */
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.payload(new MyObject("Lorem", 1900, new Date(1420416000000L)))
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.post()...</code>
      </pre>
    </div>
    <g:HTMLPanel styleName="action-panel">
      <g:HTMLPanel styleName="action">
        <g:Button ui:field="singleXmlPostButton" styleName="btn">POST</g:Button>
      </g:HTMLPanel>
      <textarea ui:field="singleXmlPostTextArea" class="form-control result" rows="3" readonly="readonly"/>
    </g:HTMLPanel>

    <p>
      Post a collection xml element.
    </p>
    <div class="highlight">
      <pre ui:field="collectionXmlPost" class="java">
        <code>requestor.req("http://httpbin.org/post")
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.contentType("application/xml") /* It must match the serializer mediaType */
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.payload(Arrays.asList(
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;new MyObject("Lorem", 1900, new Date(1420416000000L)),
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;new MyObject("Ipsum", 210, new Date(1420070400000L))))
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.post()...</code>
      </pre>
    </div>
    <g:HTMLPanel styleName="action-panel">
      <g:HTMLPanel styleName="action">
        <g:Button ui:field="collectionXmlPostButton" styleName="btn">POST</g:Button>
      </g:HTMLPanel>
      <textarea ui:field="collectionXmlPostTextArea" class="form-control result" rows="3" readonly="readonly"/>
    </g:HTMLPanel>
    
    
    <!-- JSON -->
    <p>
      Get a single json element. The mocked url <em>http://www.mocky.io/v2/54aa93c307b5f2671021ba0c</em> returns a single MyObject json element.
      Also, note that the request has a Content-Type header with the value "application/json". It enables Requestor to match the correct serializer.
    </p>
    <div class="highlight">
      <pre ui:field="singleJsonGet" class="java">
        <code>requestor.req("http://www.mocky.io/v2/54aa93c307b5f2671021ba0c").get(MyObject.class)...</code>
      </pre>
    </div>
    <g:HTMLPanel styleName="action-panel">
      <g:HTMLPanel styleName="action">
        <g:Button ui:field="singleJsonGetButton" styleName="btn">GET</g:Button>
      </g:HTMLPanel>
      <textarea ui:field="singleJsonGetTextArea" class="form-control result" rows="3" readonly="readonly"/>
    </g:HTMLPanel>

    <p>
      Get a collection json element. The mocked url <em>http://www.mocky.io/v2/54aa937407b5f2601021ba0b</em> returns a json array of MyObject.
      Also, note that the request has a Content-Type header with the value "application/json". It enables Requestor to match the correct serializer.
    </p>
    <div class="highlight">
      <pre ui:field="collectionJsonGet" class="java">
        <code>requestor.req("http://www.mocky.io/v2/54aa937407b5f2601021ba0b").get(MyObject.class, List.class)...</code>
      </pre>
    </div>
    <g:HTMLPanel styleName="action-panel">
      <g:HTMLPanel styleName="action">
        <g:Button ui:field="collectionJsonGetButton" styleName="btn">GET</g:Button>
      </g:HTMLPanel>
      <textarea ui:field="collectionJsonGetTextArea" class="form-control result" rows="3" readonly="readonly"/>
    </g:HTMLPanel>

    <p>
      Post a single json element.
    </p>
    <div class="highlight">
      <pre ui:field="singleJsonPost" class="java">
        <code>requestor.req("http://httpbin.org/post")
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.contentType("application/json") /* It must match the serializer mediaType */
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.payload(new MyObject("Lorem", 1900, new Date(1420416000000L)))
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.post()...</code>
      </pre>
    </div>
    <g:HTMLPanel styleName="action-panel">
      <g:HTMLPanel styleName="action">
        <g:Button ui:field="singleJsonPostButton" styleName="btn">POST</g:Button>
      </g:HTMLPanel>
      <textarea ui:field="singleJsonPostTextArea" class="form-control result" rows="3" readonly="readonly"/>
    </g:HTMLPanel>

    <p>
      Post a collection json element.
    </p>
    <div class="highlight">
      <pre ui:field="collectionJsonPost" class="java">
        <code>requestor.req("http://httpbin.org/post")
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.contentType("application/json") /* It must match the serializer mediaType */
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.payload(Arrays.asList(
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;new MyObject("Lorem", 1900, new Date(1420416000000L)),
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;new MyObject("Ipsum", 210, new Date(1420070400000L))))
          <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;.post()...</code>
      </pre>
    </div>
    <g:HTMLPanel styleName="action-panel">
      <g:HTMLPanel styleName="action">
        <g:Button ui:field="collectionJsonPostButton" styleName="btn">POST</g:Button>
      </g:HTMLPanel>
      <textarea ui:field="collectionJsonPostTextArea" class="form-control result" rows="3" readonly="readonly"/>
    </g:HTMLPanel>
    
    
  </g:HTMLPanel>

  </g:HTMLPanel>
</ui:UiBinder>